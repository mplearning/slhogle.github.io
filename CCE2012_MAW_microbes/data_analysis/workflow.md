---
layout: page
title: 
permalink: /CCE2012_MAW_microbes/data_analysis/workflow/
---

## Reference publication

__Hogle SL__, Bundy RA, Barbeau KA. _In prep._ Linking phytoplankton and bacterioplankton assemblage dynamics to iron-binding ligand production in a microcosm experiment. 
___


## Introduction: OTU data analysis

The analyses we're doing here are going to be using the R package "phyloseq." There are some great tutorials on how to use phyloseq [here](http://joey711.github.io/phyloseq/tutorials-index). In addition, the data that we're using here has been generated by an OTU pipeline based mainly on [UPARSE](http://drive5.com/uparse/). There is a lot of great information at the UPARSE website. The pipeline that I followed to obtain the data files 

### Load required packages


```R
library(phyloseq)
library(ggplot2)
library(reshape)
library(grid)
library(vegan)
library(DESeq2)
```


### Check package versions


```R
packageVersion("phyloseq")
packageVersion("ggplot2")
packageVersion("DESeq2")
```

    [1] ‘1.12.2’
    [1] ‘1.0.1’
    [1] ‘1.8.2’



### Import the dataset and combine individual sample files

Set working directory


```R
setwd("YOUR/WORKING/DIRECTORY")
```

Import individual OTU tables from each sample


```R
DNA07 <- subset(as.data.frame(read.table("DNA07_otutab.txt", sep="\t", header=TRUE)), select = -taxonomy)
DNA08 <- subset(as.data.frame(read.table("DNA08_otutab.txt", sep="\t", header=TRUE)), select = -taxonomy)
DNA09 <- subset(as.data.frame(read.table("DNA09_otutab.txt", sep="\t", header=TRUE)), select = -taxonomy)
DNA10 <- subset(as.data.frame(read.table("DNA10_otutab.txt", sep="\t", header=TRUE)), select = -taxonomy)
DNA11 <- subset(as.data.frame(read.table("DNA11_otutab.txt", sep="\t", header=TRUE)), select = -taxonomy)
DNA12 <- subset(as.data.frame(read.table("DNA12_otutab.txt", sep="\t", header=TRUE)), select = -taxonomy)
```

Create a list of the tables


```R
samples.list = list(DNA07, DNA08, DNA09, DNA10, DNA11, DNA12)
```

use reduce + merge to bind all the tables together


```R
OTU.tab = Reduce(function(...) merge(..., all=T), samples.list)
```

convert NAs to zeroes in the dataframe


```R
OTU.tab[is.na(OTU.tab)] <- 0
```

save a table with the combined OTUs for the samples


```R
write.table(OTU.tab, file="allsamples_otu_table", quote = FALSE, row.names = FALSE, sep = "\t")
```

Set row names to column 1 and remove the original values from that column


```R
rownames(OTU.tab) <- OTU.tab[,1]
OTU.tab <- subset(OTU.tab, select = -OTU_ID)
```

Load the previously saved OTU matrix if needed


```R
OTU.tab <- as.matrix(read.table("allsamples_otu_table", row.names=1, sep="\t", header=TRUE))
```

Load and create a taxonomy matrix


```R
taxmat <- as.matrix(read.table("rdp_tax_table", row.names=1, sep="\t", header=TRUE))
```

Load and create a metadata data frame


```R
metamat <- as.data.frame(read.table("allsamples.metadata", row.names=1, sep="\t", header=TRUE))
```

### Generate phyloseq object

Here we’ll call some of phyloseq’s functions to genearate an object called cce12 that contains metadata, OTU, and taxonomy info.


```R
OTU = otu_table(OTU.tab, taxa_are_rows = TRUE)
TAX = tax_table(taxmat)
SAMPDAT = sample_data(metamat)
cce12 = phyloseq(OTU, TAX, SAMPDAT)
```

### Lets take a look at some summary statistics

Generate OTU sums across all samples and sort


```R
OTUsums = data.frame(nreads = sort(taxa_sums(cce12), TRUE), sorted = 1:ntaxa(cce12))
```

Now calculate the number of reads in each sample and make a table


```R
samplesums = data.frame(read.count = sort(sample_sums(cce12), TRUE))
```


Most of the samples are pretty evenly sequenced with the exception of DNA08. Now plot an OTU rank abundance curve using ggplot. We can see that there are many OTUs with a very small abundance


```R
ggplot(OTUsums, aes(x = sorted, y = nreads)) + geom_line(stat = "identity", size = 1) +
  scale_y_log10() + labs(x = "OTU rank abundance", y = "Total number of reads")
```


![svg](/CCE2012_MAW_microbes/data_analysis/output_41_0.svg)


### Preprocessing data


Here we’ll do some preprocessing to remove spurious and nonabundant OTUs that we don’t want to affect downstream analysis

Here we use the subset taxa function to select only the Domain “Bacteria” while excluding “Cyanobacteria/chloroplast.” cce12_st is a new phyloseq object


```R
cce12_st <- subset_taxa(cce12, Phylum!="Cyanobacteria/Chloroplast")
cce12_st <- subset_taxa(cce12_st, Domain=="Bacteria")
```

Now we will transform the reads for each OTU in each sample to relative abundance - ie. reads for OTUx / total reads in sample x

This reuslts in 826 OTUs


```R
cce12st.rel.abun <- transform_sample_counts(cce12_st, function(x) x / sum(x))
cce12st.rel.abun
```

    phyloseq-class experiment-level object
    otu_table()   OTU Table:         [ 826 taxa and 6 samples ]
    sample_data() Sample Data:       [ 6 samples by 11 sample variables ]
    tax_table()   Taxonomy Table:    [ 826 taxa by 6 taxonomic ranks ]



Now we will remove OTUs that have a mean percentage abundance of less than 0.005%. The resulting phyloseq object has 304 OTUs


```R
cce12st.rel.abun.filter <- filter_taxa(cce12st.rel.abun, function(x) mean(x) > 5e-5, TRUE)
cce12st.rel.abun.filter
```

    phyloseq-class experiment-level object
    otu_table()   OTU Table:         [ 304 taxa and 6 samples ]
    sample_data() Sample Data:       [ 6 samples by 11 sample variables ]
    tax_table()   Taxonomy Table:    [ 304 taxa by 6 taxonomic ranks ]



Collect OTUs from cce12.rel.abun.filter and use them to filter the raw OTUs from cce12


```R
cce12.raw.filt <- prune_taxa(taxa_names(cce12st.rel.abun.filter), cce12)
```

Remove taxa not seen more than 3 times in at least 20% of the samples. This protects against OTUs with small mean & trivially large covariance


```R
cce12.raw.filt.2 <- filter_taxa(cce12.raw.filt, function(x) sum(x > 3) > (0.2*length(x)), TRUE)
```

Generate OTU sums across all samples in the new filtered set and sort


```R
OTUsums1 <- data.frame(nreads = sort(taxa_sums(cce12.raw.filt.2), TRUE), sorted = 1:ntaxa(cce12.raw.filt.2))
```

Plot new rank abundace curve based on reduced OTU set


```R
ggplot(OTUsums1, aes(x = sorted, y = nreads)) + geom_line(stat = "identity", size = 1) +
  scale_y_log10() + labs(x = "OTU rank abundance", y = "Total number of reads")
```


![svg](/CCE2012_MAW_microbes/data_analysis/output_56_0.svg)


Again make a summary table of read counts for each library


```R
samplesums_postfilter <- cbind(samplesums, 
                               data.frame(read.count.postfilter = sort(sample_sums(cce12.raw.filt), TRUE)), 
                               data.frame(read.count.postfilter.2 = sort(sample_sums(cce12.raw.filt.2), TRUE)))
samplesums_postfilter
```


Now we’ll standardize abundances to the median sequencing depth of each sample

First calculate the median for the sample sums in the filtered dataset


```R
total.median <- median(sample_sums(cce12.raw.filt.2))
```

Now create a function that standardized the relative abundance of each OTU to the median sequencing depth


```R
stdize.fun <- function(x, t=total.median) round(t * (x / sum(x)))
```

Create the standardized result


```R
cce12norm = transform_sample_counts(cce12.raw.filt.2, stdize.fun)
```

### Richness/alpha diversity of data partitioned by Fe_Treatment

Here we’ll make some richness plots of our data separated by high iron and low iron treatments. We use raw data instead of the normalized data here because many richness estimates are based on singletons and doubletons. We need to leave them in order to get meaningful estimates.

Get numerical values for richness estimates and write output as a table


```R
richness <- estimate_richness(cce12_st)
write.table(richness, file = "sample_richness_estimates.tsv", sep = "\t", row.names = T)
```


```R
p = plot_richness(cce12_st, x = "Fe_Treatment", color = "Sample_ID")
p + geom_point(data = p$data, aes(x = Fe_Treatment, y = value, color = Sample_ID), size = 4)
```


![svg](/CCE2012_MAW_microbes/data_analysis/output_69_0.svg)


Right now, we actually only care about richness plots of Chao1 and “observed” diversity so we’ll just select those


```R
psub = plot_richness(cce12_st, x = "Fe_Treatment", color = "Sample_ID", measures = c("Observed", "Chao1"))
psub + geom_point(data = psub$data, aes(x = Fe_Treatment, y = value, color = Sample_ID), size = 4)
```


![svg](/CCE2012_MAW_microbes/data_analysis/output_71_0.svg)


### Bar plots

Now let’s make some bar plots to get a fuller picture as to how the top OTUs are distributed throughout our Fe treatments. Here we’ll select the top 20 most abundant OTUs from the normalized dataset “cce12norm” and partition them by class.


```R
topOTUs = names(sort(taxa_sums(cce12norm), TRUE)[1:20])
cce12norm20 = prune_taxa(topOTUs, cce12norm)
plot_bar(cce12norm20, "Sample_ID", fill = "Family", facet_grid = ~OTU)
```


![svg](/CCE2012_MAW_microbes/data_analysis/output_74_0.svg)


To make bar plots of all OTUs combined into a particular taxonomic rank you need to use the tax_glom function.

Combine OTUs at the taxonomic rank of Class. Results in 25 OTUs


```R
glommed <- tax_glom(cce12norm, taxrank="Class")
```

Create variable “OTUS_remove” that contains the names of the 19 least abundant OTUs in the glommed dataset


```R
OTUS_remove <- names(sort(taxa_sums(glommed), FALSE)[1:20])
```

Remove the 19 least abundant Class "OTUs" from the glommed dataset


```R
glommed.red <- merge_taxa(glommed, OTUS_remove, 1)
```

This is kind of annoying....

When you make the bar plot using the phyloseq wrapper "plot_bar" it puts the components not in the same order for each sample. I don’t actually understand how this wrapper is implemented in phyloseq


```R
p <- plot_bar(glommed.red, "Sample_ID", fill = "Class")
p + geom_bar(aes(fill="Class", position="stack"))
```


![svg](/CCE2012_MAW_microbes/data_analysis/output_82_0.svg)


Ok to make this not a jumbled bar plot mess I'll do this with vanilla ggplot2. First, set up data frames produced from the tax_table and otu_tables from the glommed.red dataset


```R
OTUs.class <- data.frame(otu_table(glommed.red))
tax.class <- data.frame(tax_table(glommed.red))
```

Merge these data frames into one


```R
merged.class.plot <- merge(OTUs.class, tax.class, by="row.names", all=TRUE)
merged.class.plot
```

We'll now get rid of unecessary columns


```R
merged.class.plot.red <- subset(merged.class.plot, select=-c(Row.names, Domain, Phylum, Order, Family, Genus))
```

Now we'll put df into long format and select id.vars as "Class" using the reshape package


```R
merged.class.plot.red.m <- melt(merged.class.plot.red, id.vars="Class")
```

Finally now we'll make the bar plot with the correct ordering of the different classes, which looks a lot nicer.


```R
ggplot(merged.class.plot.red.m, aes(variable, value, fill=Class)) + geom_bar(stat="identity")
```


![svg](/CCE2012_MAW_microbes/data_analysis/output_92_0.svg)


### Detecting OTUs with differential abundance between Fe Treatments

So there seems to be some controvery in the microbiome world about whether or not to Rarefy data. Rarefying is basically a library size normalization technique that randomly subsamples reads from each library/sample in order to make all libraries contain the same number fo reads as the smallest library. This is the default normalization proceedure in QIIME as far as I can tell. A [very recent paper](https://peerj.com/preprints/1157/) states that Rarefying is a good option when your library sizes are vastly different, but if they are close to each other in read number (like ours) and you have a small sample size (also like ours) then procedures utilizing generalized linear models (like DESeq2) to be more sensitive and powerful.

Some studies have gone as far as saying that Rarefying is ["inexcusable"](http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003531). It seems like the best option for us is to model microbiome counts with a Negative Binomial model as implemented in the popular package [DESeq2](http://www.genomebiology.com/2014/15/12/550) for detecting differential expression in RNAseq data. Here we use DESeq2 to test whether any particular OTUs are significantly less or more abundant in high iron versus low iron treatments.

Import data with phyloseq, convert to DESeq2’s DESeqDataSet class


```R
FeTreat.dds = phyloseq_to_deseq2(cce12.raw.filt.2, ~ Fe_Treatment)
```

Calculate geometric means prior to estimate size factors


```R
gm_mean = function(x, na.rm=TRUE){
  exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
}
geoMeans = apply(counts(FeTreat.dds), 1, gm_mean)
FeTreat.dds = estimateSizeFactors(FeTreat.dds, geoMeans = geoMeans)
```

Running DESeq2 on non transformed data


```R
FeTreat.dds = DESeq(FeTreat.dds, fitType="local")
res = results(FeTreat.dds)
res = res[order(res$padj, na.last=NA), ]
alpha = 0.05
sigtab = res[(res$padj < alpha), ]
sigtab = cbind(as(sigtab, "data.frame"), as(tax_table(cce12)[rownames(sigtab), ], "matrix"))
write.table(sigtab, file = "diff_abun_OTU.tsv", sep = "\t", row.names = T)
sigtab_red = subset(sigtab, select = -c(Domain, Phylum, Order, Family))
```


cool - so it looks like there are 9 OTUs that are significantly more abundant in high Fe treatments (those with a negative log2 Fold-change) and 13 that are less abundant.

### Ordination of data using phyloseq, vegan, ggplot and some other stuff…

Finally we’ll make an ordination based on our community data and fit continuous environmental variable to it as factors

First define a function veganotu for extracting an OTU table from a phyloseq object and coercing it into a form vegan likes


```R
veganotu <- function(physeq) {
    OTU <- otu_table(physeq)
    if (taxa_are_rows(OTU)) {
        OTU <- t(OTU)
    }
    return(as(OTU, "matrix"))
}
```

Convert physeq metadata into vanilla R data frames


```R
keepvariables = which(sapply(sample_data(cce12.raw.filt.2), is.numeric))
physeqsd = data.frame(sample_data(cce12.raw.filt.2))[keepvariables]
physeqsd = subset(physeqsd, select = -Fe_level)
treatment = data.frame(sample_data(cce12.raw.filt.2))["Fe_Treatment"]
```

Using the normalized OTU matrix in the metaMDS function


```R
set.seed(4019)
vare.mds <- metaMDS(veganotu(cce12norm), trace = TRUE, plot = FALSE, autotransform = TRUE, noshare = FALSE, wascores = FALSE, trymax = 1000)
```

Use the score function to load sample sites into vectors. We also use plot_ordination function with the justDF option =TRUE in order to load the specific coordinates of just the OTUs.


```R
scrs.site <- as.data.frame(scores(vare.mds, display = "sites"))
scrs.site <- cbind(scrs.site, treatment = treatment)
scrs.spp <- plot_ordination(cce12norm, vare.mds, type = "species", justDF = T) # To get species coordinates
```


Now we use the envfit function to fit vectors to our continuous environmental data


```R
set.seed(152)
ef <- envfit(vare.mds, physeqsd, permu = 999)
ef
```

    ***VECTORS
    
            NMDS1    NMDS2     r2  Pr(>r)  
    Fe    0.44906 -0.89350 0.6213 0.19861  
    L1    0.26147 -0.96521 0.7724 0.05139 .
    L2    0.64802  0.76163 0.1941 0.70000  
    L3    0.24203 -0.97027 0.4189 0.45417  
    NO3  -0.54843  0.83620 0.7571 0.08194 .
    PO4  -0.58947  0.80779 0.6390 0.19861  
    SiO3 -0.19340  0.98112 0.3044 0.56667  
    ChlA -0.28796 -0.95764 0.6359 0.20556  
    ---
    Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
    Permutation: free
    Number of permutations: 720
    


Use the score function again, but this time to load direction of environmental vectors. Environmental vectors here are weighted by R<sup>2</sup> value


```R
scrs.vct <- as.data.frame(scores(ef, display = "vectors"))
```

So this was kind of confusing... ef is a list of lists. to get pvals you need to selected the pvals list from the vectors list


```R
vct.pvals <- ef[['vectors']]['pvals']
```

combine both vectors and pvals


```R
scrs.vct <- cbind(scrs.vct, vct.pvals)
```

select only rows with a P value < 0.1


```R
scrs.vct <- scrs.vct[scrs.vct$pvals < 0.1,  ]  
```

### And finally, create the plot using ggplot


```R
p <- ggplot(scrs.site, aes(x = NMDS1, y = NMDS2))
p + geom_point(data = scrs.site, aes(shape = Fe_Treatment), size = 4) + 
  coord_fixed() + ## need aspect ratio of 1!
  geom_segment(data = scrs.vct, aes(x = 0, xend = NMDS1/5, y = 0, yend = NMDS2/5), arrow = arrow(length = unit(0.25, "cm")), colour = "black") +
  geom_text(data = scrs.vct, aes(x = NMDS1/4.8, y = NMDS2/4.8, label = rownames(scrs.vct)), size = 3) +
  geom_point(data = scrs.spp, mapping = aes(x = NMDS1, y = NMDS2, color = Class), size = 1.5)
```


![svg](/CCE2012_MAW_microbes/data_analysis/output_123_0.svg)
